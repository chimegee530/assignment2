<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Tetris</title>
<style>
body {
  margin: 0;
  background: black;
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
}
canvas {
  border: 1px solid white;
}
</style>
</head>
<body>

<canvas id="game" width="320" height="640"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

const COLS = 10;
const ROWS = 20;
const SIZE = 32;

let board, piece, dropCounter, score, paused, gameOver;

const COLORS = {
  I: "cyan", J: "blue", L: "orange",
  O: "yellow", S: "green", T: "purple", Z: "red"
};

const SHAPES = {
  I: [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
  J: [[1,0,0],[1,1,1],[0,0,0]],
  L: [[0,0,1],[1,1,1],[0,0,0]],
  O: [[1,1],[1,1]],
  S: [[0,1,1],[1,1,0],[0,0,0]],
  Z: [[1,1,0],[0,1,1],[0,0,0]],
  T: [[0,1,0],[1,1,1],[0,0,0]]
};

function resetGame() {
  board = Array.from({length: ROWS}, () => Array(COLS).fill(0));
  score = 0;
  paused = false;
  gameOver = false;
  dropCounter = 0;
  piece = newPiece();
}

function newPiece() {
  const keys = Object.keys(SHAPES);
  const name = keys[Math.floor(Math.random() * keys.length)];
  return {
    name,
    shape: SHAPES[name],
    x: Math.floor(COLS / 2) - 1,
    y: -1
  };
}

function collide(p) {
  for (let y = 0; y < p.shape.length; y++) {
    for (let x = 0; x < p.shape[y].length; x++) {
      if (p.shape[y][x]) {
        const nx = p.x + x;
        const ny = p.y + y;
        if (nx < 0 || nx >= COLS || ny >= ROWS ||
            (ny >= 0 && board[ny][nx])) return true;
      }
    }
  }
  return false;
}

function merge() {
  piece.shape.forEach((row,y)=>{
    row.forEach((v,x)=>{
      if (v && piece.y+y >= 0)
        board[piece.y+y][piece.x+x] = piece.name;
    });
  });
}

function rotate() {
  const m = piece.shape.map((_,i)=>piece.shape.map(r=>r[i]).reverse());
  const old = piece.shape;
  piece.shape = m;
  if (collide(piece)) piece.shape = old;
}

function clearLines() {
  for (let y = ROWS-1; y >= 0; y--) {
    if (board[y].every(v=>v)) {
      board.splice(y,1);
      board.unshift(Array(COLS).fill(0));
      score += 100;
      y++;
    }
  }
}

function update() {
  if (paused || gameOver) return;

  dropCounter++;
  if (dropCounter > 30) {
    piece.y++;
    if (collide(piece)) {
      piece.y--;
      merge(); 
      clearLines();
      piece = newPiece();
      if (collide(piece)) gameOver = true;
    }
    dropCounter = 0;
  }
}

function draw() {
  ctx.clearRect(0,0,canvas.width,canvas.height);

  board.forEach((row,y)=>{
    row.forEach((v,x)=>{
      if (v) {
        ctx.fillStyle = COLORS[v];
        ctx.fillRect(x*SIZE,y*SIZE,SIZE-1,SIZE-1);
      }
    });
  });

  piece.shape.forEach((row,y)=>{
    row.forEach((v,x)=>{
      if (v && piece.y+y >= 0) {
        ctx.fillStyle = COLORS[piece.name];
        ctx.fillRect((piece.x+x)*SIZE,(piece.y+y)*SIZE,SIZE-1,SIZE-1);
      }
    });
  });

  ctx.fillStyle = "white";
  ctx.font = "18px monospace";
  ctx.fillText("Score: " + score, 10, 20);

  if (paused) {
    ctx.fillText("PAUSED", 120, 320);
  }

  if (gameOver) {
    ctx.fillText("GAME OVER", 90, 300);
    ctx.fillText("Press R", 110, 330);
  }
}

function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}

document.addEventListener("keydown", e=>{
  if (e.key === "r") resetGame();
  if (gameOver) return;

  if (e.key === "p") paused = !paused;
  if (paused) return;

  if (e.key === "ArrowLeft") { piece.x--; if (collide(piece)) piece.x++; }
  if (e.key === "ArrowRight") { piece.x++; if (collide(piece)) piece.x--; }
  if (e.key === "ArrowDown") { piece.y++; if (collide(piece)) piece.y--; }
  if (e.key === "ArrowUp") rotate();
});

resetGame();
loop();
</script>
</body>
</html>
